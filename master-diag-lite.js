// master-diag-lite.js - Echo Rubicon Engineering Diagnostic (Lite Version)
// Focused diagnostic for dev/engineering teams - no file manipulation, just status

const fs = require('fs');
const path = require('path');
const net = require('net');

// ===== CONFIGURATION =====
const CONFIG = {
  ROOT: path.resolve(__dirname),
  VAULT_PATH: 'D:\\Obsidian Vault',
  LOGS_DIR: 'C:\\Users\\tophe\\Documents\\Echo Rubicon\\logs',
  PORTS: { ollama: 11434, express: 49200, rust: 3000, meilisearch: 7700 },
  IGNORE_DIRS: ['node_modules', '.git', '.obsidian', '.trash', '.vscode', '__pycache__', 'dist', 'build', 'z__archive'],
  AUTO_GENERATED: ['bundle.js', 'dist/', 'build/', '.d.ts', 'generated/', 'coverage/'],
  DEAD_INDICATORS: ['dead', 'deprecated', 'backup', 'copy', 'test-', '-old', 'unused'],
  CRITICAL_FILES: [
    'main/app.js',
    'main/ipc-handlers.js', 
    'src/memory/index.js',
    'src/echo/memory/MemoryService.js'
  ]
};

// ===== ENGINEERING RESULTS STRUCTURE =====
const RESULTS = {
  timestamp: new Date().toISOString(),
  status: 'UNKNOWN',
  critical_errors: [],
  system_health: {
    memory_system: 'UNKNOWN',
    ipc_handlers: 'UNKNOWN', 
    vault_access: 'UNKNOWN',
    services: 'UNKNOWN'
  },
  file_analysis: {
    living_files: [],
    dead_files: [],
    dead_paths: [],
    missing_critical: []
  },
  status_tests: {
    passed: 0,
    failed: 0,
    warnings: 0,
    details: []
  },
  service_ports: {},
  recommendations: []
};

// ===== UTILITIES =====
function isAutoGenerated(filePath) {
  return CONFIG.AUTO_GENERATED.some(pattern => 
    filePath.includes(pattern) || 
    path.basename(filePath).includes(pattern)
  );
}

function isDeadFile(name) {
  return CONFIG.DEAD_INDICATORS.some(indicator => 
    name.toLowerCase().includes(indicator)
  );
}

function isCodeFile(file) {
  return /\.(js|jsx|ts|tsx)$/.test(file) && !isAutoGenerated(file);
}

function addTest(name, status, details = '') {
  RESULTS.status_tests.details.push({
    test: name,
    status: status,
    details: details
  });
  
  if (status === 'PASS') RESULTS.status_tests.passed++;
  else if (status === 'FAIL') RESULTS.status_tests.failed++;
  else if (status === 'WARN') RESULTS.status_tests.warnings++;
}

function addCriticalError(error) {
  RESULTS.critical_errors.push({
    error: error,
    timestamp: new Date().toISOString()
  });
}

async function checkPort(host, port, timeout = 2000) {
  return new Promise((resolve) => {
    const socket = new net.Socket();
    socket.setTimeout(timeout);
    socket.on('connect', () => { socket.destroy(); resolve(true); });
    socket.on('timeout', () => { socket.destroy(); resolve(false); });
    socket.on('error', () => resolve(false));
    socket.connect(port, host);
  });
}

// ===== CORE DIAGNOSTIC FUNCTIONS =====

async function testCriticalFiles() {
  console.log('ðŸ” Testing Critical Files...');
  
  for (const file of CONFIG.CRITICAL_FILES) {
    const fullPath = path.join(CONFIG.ROOT, file);
    if (fs.existsSync(fullPath)) {
      addTest(`Critical File: ${file}`, 'PASS');
    } else {
      addTest(`Critical File: ${file}`, 'FAIL', 'File missing');
      addCriticalError(`Missing critical file: ${file}`);
      RESULTS.file_analysis.missing_critical.push(file);
    }
  }
}

async function testMemorySystem() {
  console.log('ðŸ§  Testing Memory System...');
  
  try {
    // Test MemorySystem import
    const memoryIndexPath = path.join(CONFIG.ROOT, 'src/memory/index.js');
    if (!fs.existsSync(memoryIndexPath)) {
      addTest('Memory System Import', 'FAIL', 'index.js missing');
      RESULTS.system_health.memory_system = 'BROKEN';
      addCriticalError('Memory system index.js not found');
      return;
    }
    
    const memoryModule = require(memoryIndexPath);
    if (!memoryModule.MemorySystem) {
      addTest('Memory System Export', 'FAIL', 'MemorySystem not exported');
      RESULTS.system_health.memory_system = 'BROKEN';
      addCriticalError('MemorySystem class not exported');
      return;
    }
    
    // Test instantiation
    try {
      const instance = new memoryModule.MemorySystem(CONFIG.VAULT_PATH);
      addTest('Memory System Instantiation', 'PASS');
      
      // Test key methods
      const methods = ['buildContextForInput', 'processConversation', 'search'];
      let methodsFailed = 0;
      
      methods.forEach(method => {
        if (typeof instance[method] === 'function') {
          addTest(`Memory Method: ${method}`, 'PASS');
        } else {
          addTest(`Memory Method: ${method}`, 'FAIL', 'Method missing');
          methodsFailed++;
        }
      });
      
      RESULTS.system_health.memory_system = methodsFailed === 0 ? 'HEALTHY' : 'DEGRADED';
      
    } catch (err) {
      addTest('Memory System Instantiation', 'FAIL', err.message);
      RESULTS.system_health.memory_system = 'BROKEN';
      addCriticalError(`Memory system instantiation failed: ${err.message}`);
    }
    
  } catch (err) {
    addTest('Memory System Import', 'FAIL', err.message);
    RESULTS.system_health.memory_system = 'BROKEN';
    addCriticalError(`Memory system import failed: ${err.message}`);
  }
}

async function testIPCHandlers() {
  console.log('ðŸ“¡ Testing IPC Handlers...');
  
  const ipcPath = path.join(CONFIG.ROOT, 'main/ipc-handlers.js');
  const appPath = path.join(CONFIG.ROOT, 'main/app.js');
  
  if (!fs.existsSync(ipcPath)) {
    addTest('IPC Handlers File', 'FAIL', 'ipc-handlers.js missing');
    RESULTS.system_health.ipc_handlers = 'BROKEN';
    addCriticalError('IPC handlers file missing');
    return;
  }
  
  addTest('IPC Handlers File', 'PASS');
  
  // Check if loaded in main process
  if (fs.existsSync(appPath)) {
    const appContent = fs.readFileSync(appPath, 'utf8');
    if (appContent.includes('ipc-handlers')) {
      addTest('IPC Handlers Loaded', 'PASS');
      RESULTS.system_health.ipc_handlers = 'HEALTHY';
    } else {
      addTest('IPC Handlers Loaded', 'FAIL', 'Not imported in main/app.js');
      RESULTS.system_health.ipc_handlers = 'BROKEN';
      addCriticalError('IPC handlers not loaded in main process');
      RESULTS.recommendations.push('Add require("./ipc-handlers") to main/app.js');
    }
  }
  
  // Check key handlers exist
  const ipcContent = fs.readFileSync(ipcPath, 'utf8');
  const keyHandlers = ['appendCapsule', 'chat:send', 'qlib-extract', 'memory:build-context'];
  
  keyHandlers.forEach(handler => {
    if (ipcContent.includes(`'${handler}'`) || ipcContent.includes(`"${handler}"`)) {
      addTest(`IPC Handler: ${handler}`, 'PASS');
    } else {
      addTest(`IPC Handler: ${handler}`, 'FAIL', 'Handler missing');
    }
  });
}

async function testVaultAccess() {
  console.log('ðŸ—„ï¸ Testing Vault Access...');
  
  if (!fs.existsSync(CONFIG.VAULT_PATH)) {
    addTest('Vault Path Access', 'FAIL', `Path not found: ${CONFIG.VAULT_PATH}`);
    RESULTS.system_health.vault_access = 'BROKEN';
    addCriticalError(`Vault path not accessible: ${CONFIG.VAULT_PATH}`);
    return;
  }
  
  addTest('Vault Path Access', 'PASS');
  
  // Check key vault directories
  const vaultDirs = ['.echo', '.echo/capsules', 'clients', 'Foods'];
  let missingDirs = 0;
  
  vaultDirs.forEach(dir => {
    const fullPath = path.join(CONFIG.VAULT_PATH, dir);
    if (fs.existsSync(fullPath)) {
      addTest(`Vault Dir: ${dir}`, 'PASS');
    } else {
      addTest(`Vault Dir: ${dir}`, 'WARN', 'Directory missing');
      missingDirs++;
    }
  });
  
  RESULTS.system_health.vault_access = missingDirs === 0 ? 'HEALTHY' : 'DEGRADED';
}

async function testServicePorts() {
  console.log('ðŸŒ Testing Service Ports...');
  
  const services = [
    { name: 'Ollama', port: CONFIG.PORTS.ollama },
    { name: 'Express Backend', port: CONFIG.PORTS.express },
    { name: 'Rust Backend', port: CONFIG.PORTS.rust },
    { name: 'MeiliSearch', port: CONFIG.PORTS.meilisearch }
  ];
  
  let servicesUp = 0;
  
  for (const service of services) {
    const isUp = await checkPort('127.0.0.1', service.port);
    RESULTS.service_ports[service.name] = {
      port: service.port,
      status: isUp ? 'UP' : 'DOWN'
    };
    
    addTest(`Service: ${service.name}`, isUp ? 'PASS' : 'WARN', `Port ${service.port}`);
    if (isUp) servicesUp++;
  }
  
  RESULTS.system_health.services = servicesUp >= 2 ? 'HEALTHY' : 'DEGRADED';
}

async function analyzeFileSystem() {
  console.log('ðŸ“ Analyzing File System...');
  
  function scanDirectory(dir, baseDir = '') {
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const item of items) {
        const fullPath = path.join(dir, item.name);
        const relativePath = baseDir ? path.join(baseDir, item.name) : item.name;
        
        // Skip ignored directories
        if (CONFIG.IGNORE_DIRS.some(ignore => relativePath.includes(ignore))) continue;
        
        if (item.isDirectory()) {
          scanDirectory(fullPath, relativePath);
        } else if (isCodeFile(item.name)) {
          const normalizedPath = relativePath.replace(/\\/g, '/');
          
          if (isDeadFile(item.name)) {
            RESULTS.file_analysis.dead_files.push({
              file: normalizedPath,
              reason: 'filename_indicates_dead',
              size: fs.statSync(fullPath).size
            });
          } else {
            RESULTS.file_analysis.living_files.push({
              file: normalizedPath,
              size: fs.statSync(fullPath).size,
              type: path.extname(item.name).substring(1)
            });
          }
        }
      }
    } catch (err) {
      // Dead path - directory that can't be read
      RESULTS.file_analysis.dead_paths.push({
        path: baseDir || dir,
        error: err.message
      });
    }
  }
  
  scanDirectory(CONFIG.ROOT);
  
  addTest('File System Scan', 'PASS', 
    `${RESULTS.file_analysis.living_files.length} living, ${RESULTS.file_analysis.dead_files.length} dead`);
}

function determineOverallStatus() {
  const criticalSystemsHealthy = Object.values(RESULTS.system_health)
    .filter(status => status === 'HEALTHY').length;
  
  const hasCriticalErrors = RESULTS.critical_errors.length > 0;
  const failedTests = RESULTS.status_tests.failed;
  
  if (hasCriticalErrors || failedTests > 3) {
    RESULTS.status = 'CRITICAL';
  } else if (criticalSystemsHealthy >= 3 && failedTests <= 1) {
    RESULTS.status = 'HEALTHY';
  } else {
    RESULTS.status = 'DEGRADED';
  }
}

function generateRecommendations() {
  // Add recommendations based on findings
  if (RESULTS.system_health.ipc_handlers === 'BROKEN') {
    RESULTS.recommendations.push('Fix IPC handlers loading in main process');
  }
  
  if (RESULTS.system_health.memory_system === 'BROKEN') {
    RESULTS.recommendations.push('Repair MemorySystem class and dependencies');
  }
  
  if (RESULTS.service_ports.Ollama?.status === 'DOWN') {
    RESULTS.recommendations.push('Start Ollama service on port 11434');
  }
  
  if (RESULTS.critical_errors.length > 0) {
    RESULTS.recommendations.push('Address all critical errors before proceeding');
  }
}

// ===== MAIN EXECUTION =====
async function runLiteDiagnostic() {
  console.log('ðŸ” ECHO RUBICON ENGINEERING DIAGNOSTIC (LITE)');
  console.log('='.repeat(50));
  console.log(`Started: ${RESULTS.timestamp}\n`);
  
  // Ensure logs directory exists
  if (!fs.existsSync(CONFIG.LOGS_DIR)) {
    fs.mkdirSync(CONFIG.LOGS_DIR, { recursive: true });
  }
  
  // Run diagnostic tests
  await testCriticalFiles();
  await testMemorySystem();
  await testIPCHandlers();
  await testVaultAccess();
  await testServicePorts();
  await analyzeFileSystem();
  
  // Generate final assessment
  determineOverallStatus();
  generateRecommendations();
  
  // Console summary
  console.log('\nðŸ“Š ENGINEERING SUMMARY');
  console.log('='.repeat(25));
  console.log(`Overall Status: ${RESULTS.status}`);
  console.log(`Critical Errors: ${RESULTS.critical_errors.length}`);
  console.log(`Tests - Pass: ${RESULTS.status_tests.passed}, Fail: ${RESULTS.status_tests.failed}, Warn: ${RESULTS.status_tests.warnings}`);
  console.log(`Living Files: ${RESULTS.file_analysis.living_files.length}`);
  console.log(`Dead Files: ${RESULTS.file_analysis.dead_files.length}`);
  
  // System health
  console.log('\nðŸ¥ SYSTEM HEALTH:');
  Object.entries(RESULTS.system_health).forEach(([system, health]) => {
    const icon = health === 'HEALTHY' ? 'âœ…' : health === 'DEGRADED' ? 'âš ï¸' : 'âŒ';
    console.log(`${icon} ${system}: ${health}`);
  });
  
  // Critical errors
  if (RESULTS.critical_errors.length > 0) {
    console.log('\nðŸš¨ CRITICAL ERRORS:');
    RESULTS.critical_errors.forEach(err => console.log(`âŒ ${err.error}`));
  }
  
  // Recommendations
  if (RESULTS.recommendations.length > 0) {
    console.log('\nðŸ’¡ RECOMMENDATIONS:');
    RESULTS.recommendations.forEach(rec => console.log(`ðŸ’¡ ${rec}`));
  }
  
  // Save JSON report
  const reportFile = path.join(CONFIG.LOGS_DIR, `diagnostic-${Date.now()}.json`);
  fs.writeFileSync(reportFile, JSON.stringify(RESULTS, null, 2), 'utf8');
  
  console.log(`\nðŸ“„ Report saved: ${reportFile}`);
  console.log(`\n${RESULTS.status === 'HEALTHY' ? 'ðŸŽ‰' : 'ðŸ”§'} Diagnostic complete.`);
}

// Execute if run directly
if (require.main === module) {
  runLiteDiagnostic().catch(console.error);
}

module.exports = { runLiteDiagnostic, RESULTS };
// MemoryWriter.js - Handles writing capsules to disk
import fs from 'fs';
import path from 'path';

export class MemoryWriter {
  constructor(vaultPath) {
    this.vaultPath = vaultPath;
  }

  // Match the writeCapsule function from capsule.js
  async writeJSON(capsule, filename) {
    const capsuleDir = path.join(this.vaultPath, '.echo', 'capsules');
    const capsulePath = path.join(capsuleDir, `${filename}.json`);

    // Ensure directory exists
    fs.mkdirSync(capsuleDir, { recursive: true });

    // Write capsule
    fs.writeFileSync(capsulePath, JSON.stringify(capsule, null, 2), 'utf8');
    return capsulePath;
  }

  async writeMarkdown(capsule, filename) {
    const conversationDir = path.join(this.vaultPath, 'conversations');
    const mdPath = path.join(conversationDir, `${filename}.md`);

    // Ensure directory exists
    fs.mkdirSync(conversationDir, { recursive: true });

    // Create markdown content
    const content = `---
title: "${capsule.metadata?.userInput?.slice(0, 50) || 'AI Conversation'}"
date: ${capsule.timestamp}
model: ${capsule.model}
role: ${capsule.role}
tags: [${capsule.metadata?.agent || 'echo'}, conversation]
---

## User Input
${capsule.metadata?.userInput || ''}

## AI Response
${capsule.response}

---
Generated by ${capsule.metadata?.agent || 'Echo'} at ${capsule.timestamp}
`;

    fs.writeFileSync(mdPath, content, 'utf8');
    return mdPath;
  }

  // Compatibility method for direct capsule writing
  async writeCapsule(capsule) {
    if (!capsule || typeof capsule !== 'object') {
      throw new Error('Invalid capsule object');
    }

    // Generate filename from capsule data
    const timestamp = new Date(capsule.timestamp || Date.now());
    const dateStr = timestamp.toISOString().split('T')[0];
    const timeStr = timestamp.toTimeString().split(' ')[0].replace(/:/g, '-');
    const filename = `${capsule.role || 'assistant'}_${dateStr}_${timeStr}`;

    const results = await Promise.all([
      this.writeJSON(capsule, filename),
      this.writeMarkdown(capsule, filename)
    ]);

    return {
      capsule,
      paths: {
        json: results[0],
        markdown: results[1]
      }
    };
  }

  // Legacy method for backward compatibility
  logMarkdown(agent, userInput, reply, project = 'general', threadId = null) {
    const date = new Date().toISOString().split('T')[0];
    const logPath = path.join(this.vaultPath, 'conversations', `${threadId || date}.md`);
    
    const entry = `
### **You â†’ @${agent}**
> ${userInput}

**@${agent}**:
${reply}

ðŸ§  Tags: #${agent} #${project} #echo-session
---
`;
    
    // Ensure directory exists
    const dir = path.dirname(logPath);
    fs.mkdirSync(dir, { recursive: true });
    
    fs.appendFileSync(logPath, entry, 'utf8');
    return logPath;
  }
}